<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeremy Rode's Tech Projects: Raspberry Pi, Node.js, and Home Automation</title>
    <meta name="description" content="Explore a collection of open-source projects by Jeremy Rode, including home automation with a Raspberry Pi Pico, a Google Sheets data logger, a Google Calendar scraper, and custom hot tub and audio system controls.">
</head>
<body>

    <main>
        <h1>Jeremy Rode's Tech Projects</h1>

        <section>
            <h2>New Project: Raspberry Pi Pico W for Steam Generator Control</h2>
            <p>This project implements a new Raspberry Pi Pico based control for a Leisure Steam One Touch LS series steam generator. The factory control PCB was misbehaving, and I have wanted to implement an automatic self-flush to clean the tank, so I thought it would be a good challenge to replace it with a Raspberry Pi Pico. This is my first MicroPython project. I was originally implementing this system in C, but when I started down the path to connect a Pico W to WiFi, I decided to try out MicroPython and I was blown away by the power and rapid development/test cycles. I mostly think this project might be interesting to people because of a few new ideas that I have not seen documented well in the wild:</p>
            <p><a href="https://github.com/jeremyrode/PicoSteamControl">View Project on GitHub: Pico Steam Control</a></p>
            <h1>PicoSteamControl</h1>
<p>This project implements a new Raspberry Pi Pico based control for a <a href="https://leisure-steam.com/product-category/steam-generators/1-touch-steam-unit/">Leisure Steam One Touch LS series steam generator</a>.</p>
<p>The factory control PCB was misbehaving, and I have wanted to implement an automatic self-flush to clean the tank, so I thought it would be a good challenge to replace it with a Raspberry Pi Pico.</p>
<p>This is my first MicroPython project. I was originally implementing this system in C, but when I started down the path to connect a Pico W to WiFi, I decided to try out MicroPython and I was blown away by the power and rapid development/test cycles.</p>
<p>I mostly think this project might be interesting to people because of a few new ideas that I have not seen documented well in the wild:</p>
<h1>New ideas:</h1>
<p>This project served as a testbed for 3 new ideas that I wanted to try:</p>
<ul>
<li>Status Logging and Timestamping though WiFi</li>
<li>Capacitive Touch Sensing via a PIO State Machine</li>
<li>New Ideal Diode Peak Detector CT Interface</li>
</ul>
<h2>Status Logging and Timestamping though WiFi</h2>
<p>A major reason I was implementing much of my IoT work with boards that run full Linux (usually a Raspberry Pi Zero W) is logging and timestamping functionality. Many of these IoT systems are very difficult to debug without a persistent log that is timestamped. Both storing and retrieving persistent logs (to some sort of nonvolatile memory) and getting real time (UTC) on a microcontroller are difficult.</p>
<p>Here, this is solved by sending my log messages out to Raspberry Pi with NTP running via the network and urequests libraries:</p>
<pre><code class="language-python">def logWifi(logmessage):
    print('Log: ' + logmessage)
    res = requests.post(secrets.url, data = logmessage)
</code></pre>
<p>Remarkably simple and effective, this server could easily serve many Pico W boards. See main.py for the full code with WiFi reconnection, and error handling. <a href="https://www.coderdojotc.org/micropython/wireless/02-connecting-to-wifi/">The secrets.url uses a config file to not check in WiFi passwords or local IPs to a public Git.</a></p>
<p>The logWifi() function in main.py takes the log request and sends it to a http server (SteamLogger.js) running in Node.js that timestamps it and writes it to a file.</p>
<pre><code class="language-node">const server = http.createServer((req, res) => {
  if (req.method === 'POST') {
    let data = '';
    req.on('data', chunk => {
      data += chunk.toString();
    });
    req.on('end', () => {
      let curDate = new Date();
      let dateStr = curDate.toString();
      message = dateStr.slice(0,dateStr.length-33) + ' ' + data; //Prepend Time to message
      console.log(message);
      logfile.write(message + '\n')
      res.end('OK');
    });
  }
});
</code></pre>
<h2>Capacitive Touch Sensing via PIO State Machine</h2>
<p>After discovering that the control button on the LS1 one touch is a capacitive membrane switch, I investigated specific ICs that detect capacitive touch sensing, but this is a perfect task for a PIO state machine. This PIO-based detection ended up very reliable and has very good dynamic range: Around 250K cycles for the untouched state, and with a strong push increasing this to 6-8M cycles. A logging function serves to quantify the reliability.</p>
<p>Here is a very unoptimized PIO state machine that charges a capacitive touch sensor via an output pin and a resistor, then cycle counts the time to discharge. <a href="https://github.com/jeremyrode/RaspPiPicoTouchSensor">I’ve broke this out into its own repository</a>, and I might try to optimize it eventually.</p>
<pre><code>pull(block)                 # Get charge delay val    
mov(x,osr)                  # Load charge delay val   
wrap_target()               # Only do the above once  
mov(y, invert(null))        # Set Y to Large (All Ones)
set(pins, 1)                # Start Charging          
label("innerloop")                                    
jmp(pin, "loopescape")      # If Pin is High, Escape  
jmp(y_dec, "innerloop")     # Loop and decrement Y    
label("loopescape")                                   
mov(isr,y)                  # Move Y to CPU SR        
set(pins, 0)                # Discharge             
push(noblock)               # Push Y                  
mov(y,x)                    # Load charge delay val   
label("chargeloop")                                   
jmp(y_dec, "chargeloop")    # If !Zero, X-- and loop
wrap()                                              
</code></pre>
<h3>How it Works</h3>
<p>This code uses a PIO state machine to repeatedly charge and discharge the touch sensor detecting a change in capacitance via the time-to-charge. The touch sensor is charged via an output pin connected through 1-megaohm resistor (R1 on schematic) giving a RC time delay that can be measured by an input pin connected directly to the touch sensor.</p>
<p>The PIO state machine starts by getting the discharge time via an initial value written to the PIO state machine, that is moved to scratch register X. This is necessary, as the PIO SET instruction is limited to 31, which is nowhere near the necessary value* (1,250,000). The state machine then sets Y to all ones, sets the charge pin to "1", and counts down (via the "innerloop") until the jump pin goes low via RC discharge. The jump escapes the loop (via jumping to "loopescape"). The Y value is outputted by moving Y to the input shift register (ISR) and pushing to the FIFO. The push is nonblocking, to keep the detections going, but the FIFO will go stale if it's not read periodically. To prepare for the next detection the charge pin is set to discharge "0", and then the discharge delay is performed, but preserving the charge delay value stored in scratch register X, to Y, then looping via “chargeloop”. At this point, we return to wrap_target(), which repeats everything (except loading the charge delay to scratch register X).</p>
<p>The user space code calibrates the baseline charge time with an IIR filter, and if a difference (here 4_000_000 cycles or 32 ms) in the charge time is detected a touch event is registered. The touch detection is debounced via a time delay gate, as a single human-timescale touch event can trigger multiple PIO detections.</p>
<p>*Yes, I’m aware that large values in scratch registers can be set via the bit-reverse function of the MOV instruction, but these are a bit too large, as the smallest value is a SET of 16 (0b10000), bit reversed is 2^27, which is a delay of 1 second (2^27 / 125 MHz).</p>
<pre><code class="language-python">baseline = 350_000 # Inital state for baseline IIR Value for touch detection (350_000, connected, 4_000 bare PCB)
touch_threshold = 4_000_000 #Threshold above baseline for a touch (4_000_000, connected, 4_000 bare PCB)
time_between_touches_ms = 1000 #Debounce time for a touch
DATA_IIR_CONST = 1000 # Filtering constant for the IIR filter
sm.put(1_250_000, 0) #This sets Charging Delay and detection rate in SM clock cycles (10 ms)
while True:
    curval = 4_294_967_295 - sm.get() #State Machine counts down from 2^32
    if time.ticks_diff(time.ticks_ms(), last_touch) &gt; time_between_touches_ms: #Not a multi-touch event
        if curval &gt; baseline + touch_threshold: #We have a touch event
            last_touch = time.ticks_ms()
            print('Touch')
        else: #Only start taking button stats after the touch event has passed
            baseline = curval / DATA_IIR_CONST + baseline * (DATA_IIR_CONST - 1) / DATA_IIR_CONST #Take Baseline Stats
</code></pre>
<p>Here the python sets the discharge delay via sm.put(). An infinite loop pulls the discharge value and changes it into delay counts by subtracting from 2^32. Here the detection is debounced via a timestamp and compared to a threshold value above a baseline non-touched value. This code adapts the baseline capacitance via an infinite first-order impulse response (IIR) filter that adapts to any slow varying baseline capacitance.</p>
<h2>New Ideal Diode Peak Detector CT Interface</h2>
<p>Interfacing to Current Transformers (CTs) is a real pain; either one needs to bias the signal in the middle of the ADC range, and sample fast enough to capture the 60 Hz sine wave, extracting the RMS, or a diode envelope detector can be used. The simple diode envelope detector simplifies the ADC reading, as the output signal is DC, but the diode turn-on voltage makes the transfer function non-linear when the signal from the CT is below the diode turn-on voltage, making the current measurement inaccurate at low current.</p>
<p>Here, I’ve tried to make an ideal diode based peak detector (with gain) out of a non-inverting op amp driving though a diode. Ideally this should both make the ADC readout much simpler and more accurate, as the output is DC, and the time constant can be set via a capacitor, and make the CT more accurate as the burden resistor can be sized optimally for the CT, with the op-amp gain used to optimally fill the ADC range from the typically lower voltage from a CT in the linear regime.</p>
<h1>Schematic:</h1>
<p>The factory control board was replaced with a quad relay board from amazon, wired directly to a RJ45 (J2) breakout board from Spark Fun (Pins 8-3). This relay board replaces the factory control board, and is wired into the 220V fill solenoid, drain valve, and the 50A heater contactor. The relay board is an active low (open collector) on pins 4-7, VCC on pin 4 and ground on pin 1. I wired a 1600:1 50A Current Transformer (CT) to pins 1 and 2.</p>
<p>The factory touchpad with LED is wired to J1. From measuring with a meter, the power LED is on Pins 1 and 2 of the RJ12 connector (J1). The capacitive touch sensor is on pin 4. I think the ground shield of the cap sensor is on pin 3.</p>
<p>Note that this is the schematic that I built on a proto board with parts on hand. A PCB with a proper ground is in the PCB directory.</p>
<p><img src="./PCB/protoschematic.png" alt="Schematic" /></p>
<p>The CT burden resistor (R5) is set at 30 Ohms, calculated for good CT linearity. The output voltage from the burdgen resistor goes to an op-amp (U2A). Here U2A with feedback around a diode (D1) forms an ideal diode, with feedback though a voltage divider formed by R4/R3, here with a voltage gain of 3.2X. A 1uF capacitor (C1) stores the peak voltage from the diode (envelope detector), with a discharge time constant of ~32ms (1uF &amp; 32k Ohms). This voltage is converted by ADC0 of the Pico.</p>
<p>Testing and simulations show this time constant isn't nearly enough by a couple of orders of magnitude, the proper calculation should be how much voltage sag the sampling capacitor has over the 1/60 Hz cycle and this calculation results in the resistor sum greater than a megaohm for 1 LSB of a 12-bit ADC. Achieving the time constant with larger values can cause opamp instability and overshoot when the current changes.</p>
<p>The unused is set to an non-inverting amp of gain 1 to ground, <a href="https://www.ti.com/lit/ab/sboa204a/sboa204a.pdf">as per recommendation.</a> Note that the op amp used here needs to be rated for a common-mode voltage at the bottom rail (here ground), but not the top rail, as there is headroom between the 3.3V maximum output and the 5V supply. The <a href="https://www.ti.com/product/LM358#tech-docs">LM358 is rated for VCM down to V- but only to V+ - 2V.</a></p>
<h1>Future Ideas</h1>
<ul>
<li>Higher touch threshold for on than off</li>
<li>Low/High via separate contactors for each heating element</li>
<li>Optimize the PIO touch detection</li>
<li>Single Pin touch detection</li>
</ul>
<h2>Single Pin Optimized PIO touch detection</h2>
<p>Single pin sans resistor touch detection is very possible. The Pico has pin pull down functionality (it’s on by default), and the IO directionally can be set dynamically via PINDIRS. The state machine could be made tighter by both slowing down the clock rate such that the delay can be implemented by the SET instruction, and the SIDESET functionality can save a few instructions.</p>
<h1>Errata Discovered for time.ticks_diff()</h1>
<p>time.ticks_diff() doesn't seem to like intervals over a few days, the code was hanging. I have changed the code to use a boolean to keep toggle the state, rather than rely on elapsed time, which seems to not work after a few days.</p>
        </section>

        <section>
            <h2>Example Project: Google Sheets Data Logger</h2>
            <p>There are many ways to log data, but few are as easy, powerful, and free as Google Sheets. Originally, I was developing an app to log current and water depth data from a sump pump system in a basement using *.csv files. I thought it would be neat to have the data directly sent to a Google Sheet, having the graphs automatically update. It was actually easier than I expected, but I did think a few steps were poorly documented. So here it is, a step-by-step easy example of logging data from a Raspberry Pi running node.js directly to a Google Sheet.</p>
            <p><a href="https://github.com/jeremyrode/GoogleSheetsDataLogger">View Project on GitHub: Log Data Directly to Google Sheets</a></p>
        </section>

        <section>
            <h2>Example Project: Calendar Scraper for Time-Based Actions</h2>
            <p>Handling time and date-based events sucks. Calendars are complicated and change, and daylight savings time comes and goes. Originally, I was developing an app to schedule my spa heater around time-of-use (TOU) electric rates. The TOU rates change with season, on weekends and holidays. At first, I was using the cron daemon, but it was a real pain to make exceptions or change anything.</p>
            <p>I was thinking that the only interface I’ve ever liked is Google Calendar; so why not just use Google Calendar? So here it is, less than 100 lines of Node.js that scrapes a Google calendar and translates the calendar events into Javascript setTimeout(). Gets the function call down to <.01 s on a Raspberry Pi W2.</p>
            <p><a href="https://github.com/jeremyrode/CalendarScraper">View Project on GitHub: Calendar Scraper</a></p>
        </section>

        <section>
            <h2>Last Project: Elan System6 Control with Raspberry Pi</h2>
            <p>A GPIO Bit Banging / RS-485 Interface to an Elan System6 Integrated Multi-Zone Controller using a Raspberry Pi.</p>
            <p>I have an Elan S6 multi-zone audio controller in my house and I love it. I wanted to be able to control it via my phone! The plan was to get a Raspberry Pi to bit bang the protocol. The project was a success, but did need some custom circuitry, which is described in the GitHub repository.</p>
            <p><a href="https://github.com/jeremyrode/elancontrol">View Project on GitHub: Elan Control</a></p>
        </section>

        <section>
            <h2>Current Project: Spa Control for a Caldera Hot Tub</h2>
            <p>RS-485 Interface to a Caldera Vacanza Hot Tub using a Raspberry Pi.</p>
            <p><a href="https://github.com/jeremyrode/spacontrol">View Project on GitHub: Spa Control</a></p>
        </section>
    </main>

</body>
</html>
